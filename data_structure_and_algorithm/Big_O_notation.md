# Big O notation

"Big O"表示法（Big O notation）是用於描述演算法的效能或者複雜度的數學符號。它能讓我們評估當數據集規模增加時，演算法的運行時間或所需空間將如何變化。

Big O表示法主要分析最壞情況下的演算法性能，並將其簡化為一個單一變量的函數。這個變量通常是輸入數據的大小（n）。我們不考慮常數或者較小的項，因為當n變得很大時，它們的影響趨向於微不足道。

## 時間複雜度

- O(1): 常數時間複雜度，表示演算法的執行時間不隨輸入數據的大小變化，例如訪問陣列中的元素。

    ```go
    x := arr[1]
    ```

- O(n): 線性時間複雜度，表示演算法的運行時間與輸入數據的大小成正比，例如一個for循環。

    ```go
    for (i := 0; i<n; i++) {
      x++
    }
    ```

- O(n²): 平方時間複雜度，表示演算法的運行時間與輸入數據的大小的平方成正比，例如簡單的兩層for循環。

    ```go
    for i := 0; i < n; i++ {
      for j := 0; j < n; j++ {
        x++
      }
    }
    ```

- O(log n): 對數時間複雜度，表示每次演算法的運行都會使待處理的數據集大小減半，例如二分搜尋。

    ```go
    x := 1
    for x < n {
      x *= 2
    }
    /*
    2^k = n
    k = log n
    */
    ```

- O(n log n): 線性對數時間複雜度，例如快速排序。

    ```go
    for i := 0; i <= n; i++ {
        x := 1
        for x < n {
            x *= 2
        }
    }
    /*
    把複雜度為 log n 的 code 執行 n 次
    */
    ```


## 空間複雜度


就像時間複雜度一樣，我們也可以使用 Big O 表示法來描述算法的空間複雜度，也就是算法執行過程中所需要的記憶體空間。這裡的 "空間" 通常指的是用於存儲數據和信息的記憶體或者儲存空間。


- O(1): 常數空間複雜度，表示算法所需要的空間大小與輸入數據的大小無關。例如，如果我們只是在更改或檢查幾個固定大小的變數，則空間複雜度就是 O(1)。

    ```go
    x := 1
    x++
    ```

- O(n): 線性空間複雜度，表示算法所需的空間與輸入數據的大小成正比。例如，如果我們需要創建一個與輸入數據大小相同的數組，則空間複雜度就是 O(n)。

    ```go
    newArr := make([]int, n)
    for i := 0; i < n; i++ {
      newArr[i] = i
    }
    ```

- O(n²): 平方空間複雜度，表示算法所需的空間與輸入數據的大小的平方成正比。例如，如果我們創建了一個二維數組，並且其行數和列數都等於輸入數據的大小，則空間複雜度就是 O(n²)。

    ```go
    rows := make([][]int, n)
    for i := 0; i < n; i++ {
      row := make([]int, n)
      for j := 0; j < n; j++ {
        row[j] = j
      }
      rows[i] = row
    }
    ```

